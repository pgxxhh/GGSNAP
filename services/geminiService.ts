
import { GoogleGenAI } from "@google/genai";

// Initialize the client
const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

/**
 * Generates a cartoon avatar based on a user's photo and a character style.
 * Uses gemini-2.5-flash-image for image editing/generation capabilities.
 */
export const generateToonAvatar = async (
  base64Image: string,
  stylePrompt: string
): Promise<string> => {
  const makeRequest = async (retryCount = 0): Promise<string> => {
    try {
      // Remove header if present (e.g., "data:image/jpeg;base64,")
      const cleanBase64 = base64Image.replace(/^data:image\/(png|jpeg|jpg);base64,/, '');

      const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image',
        contents: {
          parts: [
            {
              inlineData: {
                mimeType: 'image/jpeg',
                data: cleanBase64,
              },
            },
            {
              text: `You are an expert vector illustrator specializing in "Chibi Game Sprays" and "Sticker Art".

              TASK:
              Create a **Custom Chibi Sticker** that is a CARICATURE of the user dressed as the selected Game Hero.

              PRIORITY 1: ACTION & POSE (CRITICAL - DO NOT IGNORE)
              - **MIRROR THE USER**: The character MUST be doing EXACTLY what the user is doing.
              - **PRESERVE HELD OBJECTS (STRICT RULE)**: 
                 - If the user is holding a specific object (Cup, Phone, Pen, Food, etc.), DRAW THAT EXACT OBJECT.
                 - **DO NOT** replace the user's real-world object with a game weapon, potion, or orb.
                 - If the user is drinking coffee -> Draw them drinking coffee.
                 - If the user is holding a phone -> Draw them holding a phone.
                 - You may *stylize* the object slightly to match the art style (e.g., a cartoon coffee cup), but do NOT change its identity.
              - **HANDS**: If hands are empty, you may draw them in a generic pose or holding a character-specific prop (optional).

              PRIORITY 2: FACE & IDENTITY
              - **Likeness**: The face MUST look like a cute cartoon version of the USER.
              - **Expression**: Strictly COPY the user's facial expression (Open mouth, wink, frown, laugh).
              - **Accessories**: You MUST include the user's GLASSES, EARRINGS, or HEADPHONES if visible.

              PRIORITY 3: HERO COSTUME (Cosplay)
              - **Outfit**: Draw the character in the Hero's iconic outfit described below.
              - **Hair**: Use the Hero's HAIR STYLE and COLOR.

              PRIORITY 4: ART STYLE (Chibi Sticker)
              - **Proportions**: Big head (50% of image), tiny body.
              - **Line Art**: Bold, thick, clean black outlines (Vector style).
              - **Sticker Effect**: Add a thick WHITE BORDER around the character.
              - **Coloring**: Flat, vibrant cel-shading.

              TARGET HERO DETAILS:
              ${stylePrompt}

              OUTPUT:
              - A single PNG-style image with a dark background.
              - High contrast, cute, and bold.
              `
            },
          ],
        },
      });

      // Extract the image from the response
      if (response.candidates && response.candidates[0].content.parts) {
        for (const part of response.candidates[0].content.parts) {
          if (part.inlineData && part.inlineData.data) {
            return `data:image/png;base64,${part.inlineData.data}`;
          }
        }
      }

      // If no image part was found, check for text feedback
      const textPart = response.candidates?.[0]?.content?.parts?.find(p => p.text);
      if (textPart) {
        console.warn("Model returned text instead of image:", textPart.text);
      }

      throw new Error("No image generated by the model.");

    } catch (error: any) {
      console.error(`Gemini attempt ${retryCount + 1} failed:`, error);
      
      // Retry on 500 errors up to 2 times
      if (retryCount < 2 && (error.message?.includes('500') || error.status === 500)) {
        await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1s
        return makeRequest(retryCount + 1);
      }
      
      throw error;
    }
  };

  return makeRequest();
};
